"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы. Задачу можно решить без сортировки исходного
массива. Но если это слишком сложно, то используйте метод сортировки,
 который не рассматривался на уроках
"""

"""
    Для поиска медианы был реализован свой алгоритм, который работает следующим образом
        1. Берёт число из списка
        2. Считаем количесвто числе, которое меньше данного числа
        3. Считаем количество числе, которое больше данного числа
        4. Если для данного числа пунк 2 == пункту 3, то мы нашли медиану и выходим из цикла
    Так же в данном алгоритме учтен случай повторения числа равного медиане
    Данный алгоритм я сравнил с алгоритмами в которых присуствует сортировка выполненная методом sorted и пузырьком
    Для измерения времени работы используется декоратор на основе модуля time
    Вывод:
        В результате эксперемента было выясненно, что всех быстрее работает алгоритм с сортировком методом sorted
        Рассмотрим резульаты более подробно
        Вид Алгоритма                                           Размер массива              Время выполнения работы
Алгоритм поиска медианы с помощью сортировки sorted                 1001                     0.0002129077911376953.с
Алгоритм поиска медианы без сортировки                              1001                     0.09357237815856934.с
Алгоритм поиска медианы с помощью сортировки пузырек                1001                     0.21687841415405273.с

Из данной таблицы можно сделать вывод, что алгоритм с сортировкой sorted работает всех быстрее, на втором месте алгоритм
без сортировки, предлагаю ещё раз запустить все три алгоритма с такими же параметрами, но с дугим массивом

        Вид Алгоритма                                           Размер массива              Время выполнения работы
Алгоритм поиска медианы с помощью сортировки sorted                 1001                     0.0002129077911376953.с
Алгоритм поиска медианы без сортировки                              1001                     0.029706239700317383.с
Алгоритм поиска медианы с помощью сортировки пузырек                1001                     0.21687841415405273.с

Алгоритм поиска медианы без сортировки сработал ещё быстрее, это обусловленно тем, что он завершается
сразу после того как найдет медиану, так что чем она ближе к началу массива, тем быстрее алгоримт отработает,
давайте увелим количество элементов

        Вид Алгоритма                                           Размер массива              Время выполнения работы
Алгоритм поиска медианы с помощью сортировки sorted                 10001                     0.0022745132446289062.с
Алгоритм поиска медианы без сортировки                              10001                     5.0290796756744385.с
Алгоритм поиска медианы с помощью сортировки пузырек                10001                     21.38307023048401.с

Все так же, алгоритм с sorted работает быстрее, а на втором месте алгоритм без сортировки

        Вид Алгоритма                                           Размер массива              Время выполнения работы
Алгоритм поиска медианы с помощью сортировки sorted                 10001                     0.0022745132446289062.с
Алгоритм поиска медианы без сортировки                              10001                     18.77010226249695.с
Алгоритм поиска медианы с помощью сортировки пузырек                10001                     21.38307023048401.с

Данная таблица доказывает тот факт, что алгоритм без сортировки работет с непостоянным временем, но оно менше с 
сортировкой пузырёк
"""

import random
import cProfile
import time
import copy

m = 5000
list_input = [random.randint(0, 100) for i in range(2 * m + 1)]


def time_count(func):
    def wrapper(*args):
        start = time.time()
        res = func(*args)
        finisf = time.time()
        print(f'Время выполнения функции {func.__doc__} = {finisf - start}.с')
        return res

    return wrapper

# Алгоритм для моиска медианы с помощью сортировки sorted
@time_count
def sort_find_middle(input_list):
    """
    Алгоритм поиска медианы с помощью сортировки sorted
    """
    return sorted(input_list)[len(input_list) // 2]

# Алгоритм поиска медианы с помощью сортировки пузырьком
@time_count
def sort_b_find_middle(input_list):
    """
    Алгоритм поиска медианы с помощью сортировки пузырек
    """
    i = 1
    count = 0
    temp_list = input_list.copy()
    while count < len(input_list):
        count += 1
        if i >= len(input_list):
            if temp_list == input_list:
                break
            else:
                temp_list = input_list.copy()
        for i in range(1, len(input_list)):
            if input_list[-i] > input_list[-i - 1]:
                temp = input_list[-i]
                input_list[-i] = input_list[-i - 1]
                input_list[-i - 1] = temp
    return input_list[len(input_list) // 2]


# Алгоритм поиска медианы без сортировки
@time_count
def find_middle(input_list):
    """
    Алгоритм поиска медианы без сортировки
    """
    count_b = 0
    count_s = 0
    len_input_list = len(input_list)
    for i in range(len_input_list):
        for j in range(len_input_list):
            if input_list[i] > input_list[j] and i != j:
                count_b += 1
            elif input_list[i] == input_list[j] and i != j and i > j:
                count_b += 1
            elif input_list[i] == input_list[j] and i != j and i < j:
                count_s += 1
            elif input_list[i] < input_list[j] and i != j:
                count_s += 1
        if (len_input_list // 2) in [count_s, count_b]:
            return input_list[i]
        count_s = 0
        count_b = 0


print(find_middle(list_input))
print(sort_find_middle(list_input))
print(sort_b_find_middle(list_input))
# cProfile.run('sort_find_middle(list_input)')
# cProfile.run('find_middle(list_input)')